<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
 
<!--
    Broadcast yayini ile ARP(ADDRESS RESOLUTION PROTOKOL) sorgu mesaji ni gonderiyor
ARP paketi gonderilirken Broadcast yayin ile yani tum cihazlar hedeflenerek gonderiliyor ve  broadcast y ayini icin tanimlanmis bir mac adresi var o kullanildiginda agdaki-network deki tum cihazlar hedeflenmis oluyor

Bir cihaz kendi networkunde olmayan bir cihaz i ip adresi ve submask adresi uzerinden taniyor, yani kendi agindaki cihaz ile kendi aginda olmayan cihaz i kolayca ayirt edebiliyor , diger cihaz la iletisime gecmeye calistigi zaman..

Router(modem) bagli oldugu cihazlarin ip-mac adreslerini kendi tablosunda tutuyor
Routerlar imiz internete baglanirken ki getway- cikis networkumuz...cikis agimz...rooter in ip numarasi ile public ip ile cikiyordu o rooter-modem e bagli cihazlar

Rooter a bagli olan her cihaz, kendi bagli oldugu modem-rooter in ip adresi ni biliyor.... 

Yani network disindaki bir cihaz la iletisime gecilecegi zaman, iletisime geclecek cihaz in ip adresi ile rooter in mac adresi gonderiliyor veri paketinde rooter a 

!Rooter-modem kendine bagli olan cihazlar in ip-mac aderslerini tuttugu icin kendine bagli olan farkli networklerdeki cihazlarin da birbiri ile iletisimini sagliyor..

WAN-WIDE AREAL NETWORK LERDE ORNEGIN...INTERNET BAGLANTISI DURUMUNDA 
CIHAZ1-ROOTER A YANI MODEM E ILETISIME GECECEGI IP ADRES VE MODEM IN MAC ADRESI, YANI BU ISLEMLER ICIN KULLANDIGI ORTAK MAC ADRESI SONRA MODEM-ROUTER DA INTERNET SERVIS SAGLAYACISINI IP ADRESINE YONLENDIRIYOR VE TABI KI GONDERILEN CIHAZ DA BIR MODEM E ROOTER A BAGLI ,, ONUN ROOTER I DA PAKET BILGISNI ALIYOR HANGI IP-MAC ADRESNDEN GELDIGNI BILIYOR VE KIME GIDECEGINI DE BILIYOR 

!SWITCH NASIL CALISIR
LAN(LOCAK AREA NETWORK) AYNI AGDAKKI CIHAZLARIN HABERLESMESINI SAGLIYORDU, HUBDAN FARKLI OLARAK DA BIR CIHAZ AYNI AGDAKI DIGER CIHAZLA ILETISIME GECECEGI ZAMAN, DOGRUDAN HEDEF CIHAZA GONDERIYOR DU DATAYI...

Switch aygitlari ip adresleri ile ilgilenmiyor hangi mac adresinin hangi porta bagli oldugu ile ilgilneiyor ama burdkai port fiziksel portdur
Switch cihazi hemen baglnair baglnamz bu bilgileri almiyor, yani mac-port adreslerini
Switch hostlar(cihazlar) arasinda iletisim gerceklestikce bu kayitlari tutmaya basliyor

Port dedgimz su, her pc ethternet kabolusu araciligi ile switch e baglaniyor ya iste switch e baglanan port adresi var, yani switch girisinin numarasi...baglanti noktasina port diyoruz normalde...

!Switch ler ip adresleri ile ilgilenmiyor, sadece hangi cihaz hangi port girisine baglnamis ona bakar.

VLAN(VIRTUAL LAN AREA NETWORK)
SANAL YEREL AG BAGLANTISI

Fiziksel donanimin  yazilimsal olarak sanal sekilde portlara gruplanarak bu sayede snaki birden fazla switch aygitimiz var gibi, aglara-newtorklere bolup bu networklere ozel konfigurasyon tanimlamasi mumkun oluyor
Sanal olarak bolunseler bile swtich cihazlari iki ayri agi yonettikleri icin kendi mac ve port tablolarini ayri ayri tutuyorlar
Switch ler cihazlarin mac-port numarlarini o cihazlar switch den cikarilana kadar tutarlar

!Router Nasil Calisir!

!Aglar-networkler arasi veri yonlendirilmesi ni mukun kilan aygitlardir.
!Rooter lar kendilerine ait ip adresi ve mac adresini barindiriyorlar, bu sayede cihazlarin icinde bulundugu networke sanki bir cihaz mis gibi dahil oluyorlar

Rooter aygitinin sorumlulugu, kendine bir paket gelirse, bu paket kendi ip sine gonderilmemis ise  bile hangi ip adresine gondeilmis ise o ip adresine gelen paketi yonlendirme yapabiliyor, ama normal 1 cihaz baska bir normal cihaz a boyle bir paket gonderse, eger ip adresi gondeirlen cihaz in ki ile uyusmuyhorsa paketi gonderilen cihaz dusurecektir bu paket bana ait degil diye, ve de herhangi bir yonlendirme yapmayacaktir, cuku oyle bir sorumlulugu yoktur
!Router yonlendirme islemini de sahip oldugu ip ve mac adresleri ile sagliyoir
!Rooter lar ayni anda birden fazla aga katilabilirler ve her ag icin o aga ozel ip-mac numarasi kullanirlar, ve bu sayede aglar arasi networkler arasi veri iletisimini yapabilirler

!Rooterlar kendi icinde  yonelndirme tablosu tutuyorlar...ve burda, kendisine bir ip adresi ve paket gonderildiginde bunun hangi aga bagli oldugnu biilir ve paketi o aga gonderir

!Router lar ilk once dahil oldugu network ip lerini tutuyor ve kendine o agdan bir cihz paket gonderince o cihaz in ip adersinden kendisinin dahil odugu hangi networden bu paketin geldig ve hangi networkteki cihaza iletilecegini bilebiliyor

!Router larin  yonlendirme tablolarinda kendi directly connected oldugu networklerin bigilis i oluuyor, dolayisi ile dogrudan bagli olmadigi networklerin bilgini tu tmuyor
!Bu duruma cozum olarak da static routes,  yani manuel olarak elle ekledgimz ip adreslerini kullanabiliyoruz

!Dynamic Routes daha kullanislidir


!Rooterlar in kendilarine ait ARP tablolari da vardir ve burda tum cihazlarin ip adreslerinin yaninda, mac adresleri de tutulur, cunku sadece ip adresleri ile bir cihazin hanig agda oldugu bilinir ama hangi cihaz oldugu dogrudan h edef cihaz bulunamaz mac adresi olmadan....

!Hem cihaz(hostlar) lar hem de router lar ayri ayri kendi arpt olabolari var onlari tutuyorlar

!Network interace-agkarti varistasi ile hallediyor aslinda

!Sunu da hatirlayalim ,ARP protokolu sayesinde IP adresinden mac adersinin kesfedilmesi mumkun oluyor....

!ZATEN INTERNET DEDIGMZ WIDE AREA NETWORK DE BENZER SEKILDE CALISIYOR
!INTERNET NASIL CALISIR!!!!!

Cihaz1 ornegin rooter a  ip adresini paketin icnde iletiyor hangi ip adresi ile iletisime gecekse yani ornegn bir servera yani y ayinlanmis bir websitesine.. 
Rooter(modem) da ip adersinden gonderilen paketin dis bir aga gondeildigin anliyor ve o dis ag ile de direk bir iletisimi lmadigndan dolayi, diger rooter a teslim ediyor ve rooter lar bu sekilde birbirlerine teslim ede ede en son server in bagli oldugu rooter(modem) a kadar gidiyor veri paketi ip adresine sahip olan ve mac adresiin dogrulandigi cihaza(Bu internet in 3 asamali dogrulama...araci ile mac adresi dogrulaniyor once..daha once bakmistik buna) iletilmis oluyor bu cihaz server oluyor..server da host-cihaz lardan bir tanesidir

!Yani esasinda bizim internete baglnamamiz da bir network olaydiir...cok daha buyuk olcekde bir network connection dir...

!Ag-networkleri router lar sayesinde alt-aglar a bolerek ornegin sirketlerde her bir departman icin bir subnetwork olusturabiliyoruz...
!Neden alt aglara bolunmek istenir cunku, surdurulebilirlik icin, ve herhangi bir depratmanda cikabilecek bir network probleminin sadece o departmanin etkilemesi diger lerinn ondan etkilenmemesi saglanir, eger tum depratmanlar tek bir aga bagli olsa,  her hangi birinin agda yasayacagi problemden tum departmanlar etkilenecektir

!Parent durumndaki routerlar, kendilerine bagli alt-routerlar ve onlara bagli olan cihazlara gelen herhangi bir data paketi, routerlar a oncelikle gelecegi icin, routerlar yonlendirme tablosunda, da  ip adrfresi olarak router in ip si tutuluyor birbirlerinde cunku oncelikel router a iletiliyor paketler


!AG-NETWORK PROTOKOLLERI NEDIR? 
INTERNET ARACILIGI ILE DATA ALISRVSERISLERININ PRENSIPLERI VE YAPACAGIMZ DATA ALISVERISININ TURUNE GORE FARKLI KURALLARI VARDIR....ISTE BUNLAR DIR PROTOKOLLER...

1-ARP PROTOKOLU(ADRESS RESOLUTINO PROTOKOL)
iP ADRESLERI U ZERINDEN MAC ADRESNI OGRENMEMIZI SAGLIYORDU
MAC-AG KARTI ADRESI-KIMLIK NUMARASI- NETWORK INTERFACEID NUMBER

!Iki cihaz iletisime gececegi zaman, switchler vasitasi ile vs, ip adresi ne ARP sorgusu ile o agdaki tum cihazlara broadcast  yayini ile, data paketi gonderecegi ip adresinin mac adresini sorgulayabiliyor ve o ip adresi hangi cihaza ait ise o mac adresini gonderiyor ama ilk basta ip adresine soran hangi cihaz ise o cihaz paket iicnde kendi ip -mac adresini de koydugu icin, kaynak cihaz in ip-mac adresini kendi arp tablosuna kaydediyor, bir daha ki kontak kurma duruumunda direk artik mac-ip adresi bilindigi iicn kontak kuruabliyoalr

!FILE TRANSFER PROTOKOL(FTP)

Lokal bir cihazimiz  uzerinden server-cihazimizdan bir dosya talep ederek bu protokol sayesinde talep ettigmz dosyayi sunucudan alabiliyoruz

(client)10.168.1.10  ->request  172.32.45.55(FTP  Server)
(client)10.168.1.10  text.txt<-request  172.32.45.55(FTP  Server)
Tabi dosya sunucusunun dosyayi isteyn client-in ip adresine acik olmasi gerekiyor

!SMTP-SIMPLE MAIL TRANSFER PROTOCOL 

mail gonderme islemlerinde kullanidgimz bir protokoldur

POP3-IMAP YAKLASIMLARINDAN BIR TANESI  ILE MAIL ICERIGINI GONDEIRLEN CIHAZ KENDI CIHAZINDA GORUNTULEYEBILIYORLAR

email-gonder -> SMTP PROTOCOLU ARACILIGI ILE -> GMAIL SMTP SERVER 172.32.45.55 -> SMTP-INTERNET ARACILIG ILE OUTLOOK SMTP SERVER(CUNKU GONDERILEN MAIL ADRESI OUTLOOK) -> POP3 VEYA IMAP ARACILIG ILE HEDEF PC DEKI KULLANICI MAILL INI ACITGINDA KENDISINE GELEN MAIL I GORUNTULEYEBILECEKTIR VE SONRASINDA DA HER SEFERNE GELEN MAILLERINI GORECEKLERDIR HER SEFERNDE....


!HTTP-HYPER TEXT TRANSFER PROTOCOL 
Her turlu media icegini , RESIM, VIDEO, TEXT icerigi web-internet uzerindnen aktrmamizi  mumknun kilan bir protokoldur 

CIHAZ1(10.168.1.10)
WEB TARAYICI->REQUEST->WEBSERVER CIHAZI(2)(143.32.44.12 = www.linuxdersleri.com-DIREK TARAYICIDA BUNU ACMAK BIR REQUEST GONDERMEKTIR....)REQUEST ILE DIYORUZ KI BIZE SEN 143.32.44.12=www.linuxdersleri.com BU IP LI VE BU DOMAIN ILE SERVER OLARAK BANA WEBSITENIN ICERIGINI GONDER DIYORUZ O DA BIZE TABI KI O WEBSITESININ FRONT-END YANI CLIENT-KULLANICISININ GORTUNTULEYEBILECEGI YANI TARAYICIDA GORUNTULEYEBILECEGI DOSYALAR OLAN INDEX.HTML, CSS VE JAVASCRIPT DOSYALARINI KULLANICINN BROWSER ARACILIGI ILE GORUNTULYEBILMESINI SAGLIYOR....YANI UZAKTA KAYNAGI BULUNAN BIR WEBSITESINI SENIN UZAK WEB SITESINDEN GORUNTULYEBILMENI SAGLIYOR TARAYIC ARACILIGII ILE....
SONRA WEBSERVER DA BU PROTOKOLUNU BILDIGI ICIN...
Bunu saglayan http protocoludur...ag uzerinden veriyi gonderiyoruz..... 

!Bir webserver a istek gonderilmesi yani bir web sayfasnin acilmasi procoess inin detayli incelnemesi

When a client (typically a web browser) accesses a webpage, it engages in HTTP (Hypertext Transfer Protocol) communication with a server. This process involves several steps to display the webpage to the user. Here's a simplified overview of how it works:

1. User Requests a Webpage:
When you type a URL (like https://www.example.com) into your browser and press Enter, the browser interprets this as a request for a webpage.
The browser first needs to find out the IP address of www.example.com. It does this through a DNS (Domain Name System) lookup. DNS translates the human-readable domain name into an IP address that computers can understand.
2. Browser Sends HTTP Request:
Once the browser knows the IP address of the server hosting www.example.com, it sends an HTTP request to that server. This request typically uses the GET method to ask for the content of the webpage.
The request includes various pieces of information, like the URL, type of browser (user agent), types of content the browser can handle (accept headers), and any cookies related to the domain.
3. Server Processes the Request:
The server receives the HTTP request and processes it. This process can involve running server-side scripts (like PHP, Python, or JavaScript in Node.js), accessing a database, or performing other tasks to generate the requested content.
The server then responds with an HTTP response message. This response includes a status code (like 200 for a successful response, 404 for not found, etc.), server information, content type, and the actual content, which is typically an HTML file.
4. Browser Renders the Webpage:
The browser receives the HTTP response and renders the webpage from the HTML it received.
If the HTML references other resources like CSS files, JavaScript files, images, or videos, the browser makes additional HTTP requests to fetch these resources.
Each resource is requested and fetched in a similar manner, with the browser sending an HTTP GET request and the server responding with the content.
5. Additional Interactions:
As you interact with the webpage (like clicking links, submitting forms, etc.), the browser may make additional HTTP requests to the server. These requests can include POST requests (often used for form submissions), AJAX requests (for dynamic content loading without reloading the whole page), and so on.
Example Scenario:
User Action: A user types https://www.example.com in their browser.
DNS Lookup: The browser performs a DNS query to find the IP address of www.example.com.
HTTP Request: The browser sends an HTTP GET request to the server's IP address.
Server Response: The server processes the request, finds or generates the appropriate HTML content, and sends it back.
Rendering: The browser receives the HTML and starts rendering the webpage. It requests additional resources (CSS, JS, images) as needed.
Display: The user sees the fully loaded webpage on their screen.
The entire process happens quite quickly, allowing users to access and interact with webpages seamlessly. Behind the scenes, a combination of networking, server-side processing, and browser rendering works together to make this possible.


Server Response
Processing the Request:

When the server receives the HTTP request, it needs to determine what content to send back. This involves interpreting the URL and any additional data (like headers or cookies) sent by the client.
If the request is for a dynamic page, server-side scripts (e.g., written in PHP, Python, Java, etc.) might run to generate the HTML. This could involve querying databases, processing data, and dynamically creating the HTML content based on various factors (like user data, time of day, etc.).
Sending the Response:

The server prepares an HTTP response that includes a status code (e.g., 200 OK for success), response headers (like content type, caching policies), and the body, which is usually the HTML content of the requested webpage.
If there are errors (like the requested resource doesn't exist), the server sends an error code (e.g., 404 Not Found) and possibly an error page.
Rendering
HTML Parsing and Rendering:

The browser receives the HTML and begins parsing it. Parsing converts the HTML (which is just text) into a Document Object Model (DOM), a tree-like structure representing all the elements of the page.
As the browser parses the HTML, it also encounters references to external resources like CSS files, JavaScript files, images, and videos.
Fetching Additional Resources:

The browser sends additional HTTP requests to fetch these external resources. Each of these is processed by the server similarly to the initial request.
CSS files dictate the styling of the webpage, while JavaScript files can add interactivity and dynamic content.
Executing Scripts and Applying Styles:

Once CSS is loaded, the browser applies the styles to the DOM. The visual layout of the page begins to take shape.
JavaScript is executed, which can manipulate the DOM, alter styles, or even fetch additional data asynchronously (using AJAX).
Display
Rendering to the Screen:

The browser combines the DOM with the CSS styles to render the page. This process involves calculating the layout of each element, applying styles, and painting the content on the screen.
This step is computationally intensive as it involves calculating layouts, styles, and redrawing the page in the browser window.
Dynamic Updates and User Interaction:

As the user interacts with the page (clicking links, filling forms, etc.), JavaScript can respond to these interactions, making changes to the DOM and updating the page dynamically.
The page can make further HTTP requests (like AJAX calls) to load new content without reloading the entire page.
Final Display:

The user sees the fully loaded and interactive webpage. All the content, styles, and scripts have been combined to present the final product.
The page may continue to update dynamically as the user interacts with it or as new data is loaded.
In summary, during the server response, the server processes the client's request and sends back the necessary data (HTML, errors, etc.). During rendering, the browser interprets this data, fetches additional resources, and builds the page visually. Finally, in the display phase, the fully formed webpage is presented to the user, where it can be interacted with and dynamically updated.

When a web browser requests a webpage, like an index.html file, and receives it as a response from a server, the file is not permanently stored in a specific folder on the client's PC like a downloaded file would be. Instead, it is temporarily stored in a part of the computer's memory allocated to the browser. This process involves the following steps:

Temporary Storage in Memory:

The index.html file is held in the browser's memory (RAM). This is a temporary storage that allows the browser to render and display the webpage. The file exists here only as long as it is needed for display and interaction in the browser.
Browser Cache:

The browser may also store the file in its cache, which is a designated space on your hard drive. Caching helps in faster loading of the webpage when you visit it again.
Cached files are stored according to the browser's caching policies and may be deleted when the cache is cleared, or when the browser decides to free up space.
Rendering and Display:

While in memory, the browser parses and processes the index.html file (along with any associated CSS, JavaScript, images, etc.) to render the webpage for display on your screen.
Not a Permanent File:

Unlike files that you download (like a PDF or an image), which are saved to a specific location on your hard drive, the index.html file in this context is not saved in a user-accessible folder. It is only temporarily used for rendering the webpage and is discarded after the browser tab or window is closed, or the cache is cleared.
Privacy and Security:

This temporary nature of webpage storage is also a part of privacy and security measures. It ensures that web content doesn't permanently occupy space on your computer without your explicit action (like downloading a file) and that it can be easily cleared (by clearing the cache).
In summary, the index.html file sent from the server is stored temporarily in the browser's memory and possibly in its cache. It is used for rendering the webpage you see on your screen and does not exist as a permanent file on your PC in a specific folder.


Parsing HTML
HTML Parsing:
The browser reads (or "parses") the HTML file to understand its structure and content. During this process, it converts the text of the HTML file into a structure it can use - the Document Object Model (DOM).
The DOM represents the hierarchical structure of the webpage, making it possible for the browser to understand which HTML elements are where, and how they are nested or related.
Processing CSS
CSS Interpretation:
Along with HTML, the browser also retrieves and parses CSS (Cascading Style Sheets) linked within the HTML. CSS defines how the HTML elements should be displayed visually.
The browser combines information from the CSS with the DOM to create the Render Tree, which represents both the structure of the webpage and its visual style.
JavaScript Execution
Executing JavaScript:
If the webpage includes JavaScript (linked or embedded in the HTML), the browser executes this JavaScript. This can manipulate the DOM, change styles, or even fetch additional data dynamically.
JavaScript execution is a critical part of modern webpages, allowing for interactive and dynamic content.
Layout Calculation
Layout Calculation:
The browser calculates the layout of each visible element on the webpage. This involves determining the exact size and position of each element based on the DOM and CSS rules.
Rendering
Rendering to the Screen:
Finally, the browser paints the webpage on the screen. This process involves drawing the elements, text, images, etc., in their correct positions as defined by the layout calculations.
Dynamic Updates
Dynamic Updates (if applicable):
After the initial rendering, the webpage can be updated dynamically. JavaScript can modify the DOM and CSS styles, leading the browser to re-calculate layout and re-paint the affected parts of the webpage.
In summary, when a browser renders a webpage, it reads and processes the HTML, CSS, and JavaScript to construct the webpage visually. The process involves parsing the HTML to create a DOM, applying styles from CSS, executing JavaScript, calculating layout, and finally painting the webpage on the screen for the user to interact with.


!SSL- TLS PROTOKOLLERI 
!HTTPS(HTTP SECURE)
SSL onceleri cok kullanilirdi ama artik daha cok TLs protokolu kullanilir
Ag  uzerindeki iletisimin guvenli olmasi protokoller 
Gunumuzde daha cok TLS kullanilir 
Veriler ag da tasinirken veirler sifrlenerek, agdaki gozlemcilerin, gormeisni engellemek, cunku http protokolu kendisi bir sifreleme yapmiyor dogrudan acik bir sekilde, veriyi server a ag araciligi ile gonderiyor ... 
Agdaki hacker veya art niyetli gozlemci ag uzerinden gonderilen data yi gortuntuleyebilir

TLS sayesinde http tafigmizi sifreleyerk https haline getierek, verilerimzi sifreli sekilde network uzerinden server a gonderirirz ve bu sayede, agda bulunan hacker,gozlemci ler bu verileri okuyamazlar.. 
Sifrelen verilerin okunabilmesini saglayan anahtar da yalnizca server da bulundugu icin, sadece server da bu clienttan gondeirlen verilerin okunmasi saglanir

Server da ynitinin yine sifreli sekilde gonderiyor https ile 


!FTP + TLS => FTPS(FTP SECURE)
FTP TLS ILE BIRLITKE KULLANILARAK DOSYA TRANSFERININ SIFRELI BIR SEKILDE GERCEKLESTIRILMESINI SAGLIYOR 

!Your connection is not private hatasi aliyorsak bir siteye baglanirken anlaamliyzi ki o sitenin-server inin tls sertifikasi yok-tls  yani o siteye girereken ki o site tarafindan kullanilan her turlu bilgimiz hacker veya gozlemciler taraifdan calinabilir....ondan dolayi da mumkunse yapmak istedgimz islemi bska bir siteden yapalim o zaman


!SSH PROTOKOLU -  SECURE SELL 

Uzaktaki bilgisyarlara-yani server a  guvenli bir sekilde herhangi bir noktadan direk olarak baglanmamizii sagliyor
Baglantiyi ve veri alisverisini guvenli seklde  yapmamizi sagliyor

SSH + FTP = SFTP(SECURE FTP) guvenli veri transferini sagliyor, dosya ttransferini sagliyor 


DNS-DOMAIN NAME SYSTEM
DNS SUNUCUSU - PROTOKOLU 

CLIENT(153.16.119.211)==>WWW.LINUXDERSLERI.COM(185.199.108.153)

!DNS BIZIM ICIN DOMAIN NAME I WWW.LINUXDERSLERI.COM BUNU , O DOMAIN NAME IN IP ADRESINE DONUSTURUYOR, 185.199.108.153....

!DNS SUNUCUSU ISIM LISTESI SEKLIDNE DOMAIN-NAME KARSISINDA IP ADRESLERINI TUTUYOR...KI 

HTTP ISTEGI GONDERILINCE..DNS SUNCUSUNA GELIR ORDA GONDERILEN ADRES- IN HANGI IP ADRESINE KARSILIK GELDIGI BULUNUR VE SONRA REQUEST ISTEGI O IP ADRESINE DOGRU YOLUNA DEVAM EDER...


DEFAULT OLARAK DNS SUNUCUSU INTERNET SAGLAYCIMZ OLUYOR ZATEN, VE BU BAZEN BAZI SITELERE ERISMIMIZI SINIRLAYABILIYOR BOYLE DURUMLARDA GOOGLE IN SUNDUGU 8.8.8.8 DNS SUNUCUSUNU KULLANABILIRIZ


!DNS SERVERLAR BIZIM INTERNET SERVIS SAGLAYACIMIZ OLUYOR DEFAULT OLARAK VE NEDEN BU DNS SERVER DEGISTIRILMEK ISTENIYOR VE ISTENDIGINDE NASIL DEGISTIRILIYOR? 

Your DNS server is a crucial part of how you access the internet, but it's not necessarily provided by your internet service provider (ISP), although that's often the case by default. Let's break down what a DNS server is and why some people choose to change their DNS server settings:

What is a DNS Server?
DNS (Domain Name System) servers translate human-readable domain names (like www.openai.com) into IP addresses that computers use to communicate (like 192.0.2.1).
ISP DNS Servers: By default, your ISP assigns DNS servers for your internet connection. These servers are responsible for resolving domain names into IP addresses when you access websites.
Role: The DNS server is like an address book for the internet, converting easy-to-remember domain names to the numerical IP addresses needed to locate and connect to devices across the network.
Why Some People Change Their DNS Server to Google's 8.8.8.8:
Speed:

Some users find that Google's DNS servers (8.8.8.8 and 8.8.4.4) or other third-party DNS services like Cloudflare (1.1.1.1) are faster than their ISP's DNS servers. Faster DNS resolution can speed up the time it takes to load web pages.
Reliability:

Google's DNS servers are known for their reliability. If an ISP's DNS servers are unreliable or frequently go down, switching to a more reliable DNS service can improve overall internet stability.
Security:

Some alternative DNS providers offer additional security features, such as protection against phishing attacks, malware, and other online threats.
Privacy Concerns:

ISPs can track your browsing history through their DNS servers. Some users switch to alternative DNS services to reduce this kind of tracking, although it's important to note that alternative DNS providers have their own privacy policies.
Bypassing Censorship or Geoblocks:

In some cases, changing the DNS server can help bypass regional internet restrictions or geoblocks, as the DNS request is routed through different servers that might not enforce the same restrictions.
Content Filtering:

Some DNS services offer content filtering options, which can be useful for blocking unwanted content, such as adult websites in family settings.
Considerations:
Trust: When you switch from your ISP's DNS to another provider like Google, you're shifting your trust from one organization to another. It's important to consider the privacy and data handling policies of the DNS provider you choose.
Configuration: Changing DNS settings can be done on individual devices, routers, or even at the network level. Proper configuration is essential to ensure that the new DNS settings are effective and secure.
In summary, your DNS server could be provided by your ISP, but you have the option to change it. People switch to services like Google's DNS for reasons like speed, reliability, security, privacy, and additional features. The choice of DNS server can have a noticeable impact on your internet experience.


!NASIL DNS SERVER DEGISTIRILEBILIR?

Switching from your ISP's DNS server to another provider, like Google's DNS, involves changing the DNS settings on your device or router. Here's how you can do it:

Switching DNS on a Router
Changing the DNS settings on your router will affect all devices connected to that router.

Access Router Settings:

Open a web browser and enter your router’s IP address in the address bar (common addresses are 192.168.1.1 or 192.168.0.1). You may need to check your router’s manual or label for the specific address.
Login to the Router:

Enter your username and password. If you haven’t changed them, the default credentials might be something like admin for both username and password, or provided in the router’s manual.
Find DNS Settings:

Look for a section named “DNS Settings,” “Network Settings,” or something similar.
Enter DNS Server Addresses:

Replace the existing DNS addresses with Google’s DNS addresses: 8.8.8.8 and 8.8.4.4.
Save and Reboot:

Save your changes and reboot the router if necessary.
Switching DNS on Individual Devices
You can also change the DNS settings on individual devices like computers, smartphones, or tablets.

Windows
Control Panel: Open the Control Panel and go to “Network and Sharing Center.”
Change Adapter Settings: Click on “Change adapter settings.”
Properties: Right-click your network connection and select “Properties.”
Internet Protocol Version 4 (TCP/IPv4): Select it and click “Properties.”
Use the Following DNS Server Addresses: Enter 8.8.8.8 and 8.8.4.4 as your preferred and alternate DNS servers, respectively.
Save: Click “OK” to save your changes.
macOS
System Preferences: Open System Preferences and click on “Network.”
Advanced: Select your network (Wi-Fi or Ethernet) and click “Advanced.”
DNS: Go to the “DNS” tab.
Add DNS Servers: Click the + button and add 8.8.8.8 and 8.8.4.4.
Apply: Click “OK” then “Apply.”
Android
Settings: Go to Settings and select “Wi-Fi.”
Modify Network: Tap and hold on your connected Wi-Fi network, then select “Modify network.”
Advanced Options: Show advanced options and change “IP settings” to “Static.”
DNS: Enter 8.8.8.8 and 8.8.4.4 in the DNS fields.
Save: Save the changes.
iOS
Settings: Open Settings and tap on “Wi-Fi.”
Wi-Fi Network: Tap on the i icon next to your Wi-Fi network.
Configure DNS: Tap on “Configure DNS” and select “Manual.”
Add Server: Tap “Add Server” and enter 8.8.8.8 and 8.8.4.4.
Save: Tap “Save.”
Important Notes
After changing DNS settings, it may be necessary to restart your device or clear the DNS cache for the changes to take effect.
Always make sure you trust the DNS provider you are switching to, as DNS plays a crucial role in your internet security and privacy.
If you encounter connectivity issues after changing DNS settings, you can revert to the original settings or try alternative DNS servers.

!DNS  SUNUCULARI FILTRELEMEK VEYA ENGELLEMEK ISTEDIKLERI IP ADRESLERINI, GECERSIZ IP ADRESI ATAYARAY YAPIYORLAR ORNEGIN WWW.EXAMPLE.COM  DOMAIN NAME ININ KARSINA 127.0.0.1 GIBI LOCAK PC NIN DEFAULT IP ADERSIN OLAN SONUCUNDA HICBIRSEY OLMAYAN IP ADRESLERI ATAMASI YAPIYORLAR...

!DHCP - DYNAMIC HOST CONFIGURATION PROTOCOL

INTERNET UZERINDE VERI ALISVERISI ICIN..

1-IP ADRESI(CIHAZIN AG UZERINE KATILABILMESI ICIN IP OLMASI SART)
2-SUBNET MASK DEGERI(IP ADRESLI CIHAZIN HANGI AGDA OLDUGNU BILINMESI ICN GEREKLI-AYNI AGDAKI CIHAZLAR AYNI SUBNET MASK DEGERINE SAHIP ) 
3-DEFAULT GATEWAY BILGISI(LOKAL AGIMIZ DISINDAKI BIR HOST ILE ILETISIME GECMEK ISTEDIGMZDE KULLANIGIMZ ROUTER-MODEM-GATTEWAY IN IP ADRESI DIR)
4-DNS SERVER IP ADRESI(DOMAIN NAME IN HANGI IP YE KARSILK GELDIGNIN BIZE VERECEK OLAN DNS SERVER HIZMETINI BILEMMIZ GEREKYOR , BU GENELLIKLE INTERNET SERVICE PROVIDER BIZE SAGLIYOR...YA DA DEGISTIRILEBILIR GOOGLE IN SUNDUG DNS:8.8.8.8 ILE )


!DHCP DEDGIMZ YAPI BU 4 BILGIYI OTOMAITK OLARAK ADGAKI TUM CIHAZLARA UYHGUN SEKILDE TANIMLAYAN YAPIDIR

!BIR CIHAZ AGA KATILDIGINDA ILK BASTA HICBIR BILGISI YOKTUR, IP,SUBNETMASK,GATEWAY,DNS AGA KATILDIGINDA DHCP SUNUCUSU NA KESIF MESAJI GONDERIYOR CIHAZ, DHCP SUNUSU DA IP,SUBNET,GATEWAY VE DNS BILGILERINI ATAMA YAPIYOR

!DHCP SUNUCUSU EGER EV VEYA KUCUK OFIS TE ISEK MODEM YA DA ROTUER DIR AKSI DURUMLARDA BUYUK ISLETMELERDE DHCP SUNUCUSU KURULUUYOR AYRI OLARAK

!TEMEL AG KOMUTLARI 
!ping araci
bu arac sayesinde agimizdaki-networkumuzdeki cihazlarin erisilebilrlgini ve tepki surelerini kontrol edebiliriz
ping araci hedefteki cihaza kontrol paketi gonderiyor ve bu kontrol paketinin karsi tarafa ulasip ulasmadgi ve paketin ne kadar surede gidip ne kadar surede geri geldigi gibi bilgileri bize sunmasidir. 
Bu sayede aramizda iletisimi agin kontrolunu gerceklestirebiliyoruz

!ping www.linux.com  seklinde kullaniriz 
Ve  biz CTRL-C ile durduruna kadar kontrol etmeye devam edecektir 

adem@adem:~/utv/test/Linux-works$ ping www.linux.com
PING www.linux.com (23.185.0.3) 56(84) bytes of data.
64 bytes from 23.185.0.3 (23.185.0.3): icmp_seq=1 ttl=58 time=4.90 ms
64 bytes from 23.185.0.3 (23.185.0.3): icmp_seq=2 ttl=58 time=4.78 ms
64 bytes from 23.185.0.3 (23.185.0.3): icmp_seq=3 ttl=58 time=5.31 ms
64 bytes from 23.185.0.3 (23.185.0.3): icmp_seq=4 ttl=58 time=5.20 ms
64 bytes from 23.185.0.3 (23.185.0.3): icmp_seq=5 ttl=58 time=5.37 ms
64 bytes from 23.185.0.3 (23.185.0.3): icmp_seq=6 ttl=58 time=5.11 ms
64 bytes from 23.185.0.3 (23.185.0.3): icmp_seq=7 ttl=58 time=5.40 ms
64 bytes from 23.185.0.3 (23.185.0.3): icmp_seq=8 ttl=58 time=5.07 ms
64 bytes from 23.185.0.3 (23.185.0.3): icmp_seq=9 ttl=58 time=5.21 ms
64 bytes from 23.185.0.3 (23.185.0.3): icmp_seq=10 ttl=58 time=5.37 ms
64 bytes from 23.185.0.3 (23.185.0.3): icmp_seq=11 ttl=58 time=5.37 ms
64 bytes from 23.185.0.3 (23.185.0.3): icmp_seq=12 ttl=58 time=4.93 ms
^C



-->